From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Phoenix616 <max@themoep.de>
Date: Mon, 28 Jun 2021 22:38:29 +0100
Subject: [PATCH] Rate options and timings for sensors and behaviors

This adds config options to specify the tick rate for sensors
 and behaviors of different entity types as well as timings
 for those in order to be able to have some metrics as to which
 ones might need tweaking.

diff --git a/src/main/java/co/aikar/timings/MinecraftTimings.java b/src/main/java/co/aikar/timings/MinecraftTimings.java
index b9cdbf8acccfd6b207a0116f068168f3b8c8e17d..fe225310e4b62e7bded3521d3ddf4092c25a3645 100644
--- a/src/main/java/co/aikar/timings/MinecraftTimings.java
+++ b/src/main/java/co/aikar/timings/MinecraftTimings.java
@@ -114,6 +114,14 @@ public final class MinecraftTimings {
         return Timings.ofSafe("Minecraft", "## tickEntity - " + entityType + " - " + type, tickEntityTimer);
     }
 
+    public static Timing getBehaviorTimings(String type) {
+        return Timings.ofSafe("Behavior - " + type);
+    }
+
+    public static Timing getSensorTimings(String type) {
+        return Timings.ofSafe("Sensor - " + type);
+    }
+
     /**
      * Get a named timer for the specified tile entity type to track type specific timings.
      * @param entity
diff --git a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
index 26e18a08a7f0bd704ff3055ce3a7814191450c85..2a3be23f52de7a960e0e323dd507579422b5b30d 100644
--- a/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
+++ b/src/main/java/com/destroystokyo/paper/PaperWorldConfig.java
@@ -3,6 +3,7 @@ package com.destroystokyo.paper;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.stream.Collectors;
 import net.minecraft.world.Difficulty;
@@ -11,6 +12,7 @@ import net.minecraft.world.entity.monster.Vindicator;
 import net.minecraft.world.entity.monster.Zombie;
 import com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray.EngineMode;
 import org.bukkit.Bukkit;
+import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.spigotmc.SpigotWorldConfig;
 
@@ -820,5 +822,33 @@ public class PaperWorldConfig {
     private void fixInvulnerableEndCrystalExploit() {
         fixInvulnerableEndCrystalExploit = getBoolean("unsupported-settings.fix-invulnerable-end-crystal-exploit", fixInvulnerableEndCrystalExploit);
     }
+
+    private Map<String, Integer> tickRates = new HashMap<>();
+    private void tickRates() {
+        config.addDefault("world-settings.default.tick-rates.sensor.villager.secondaryplaces", 40);
+        config.addDefault("world-settings.default.tick-rates.behavior.villager.positionvalidate", 20);
+        tickRates = new HashMap<>();
+        log("Tick rates:");
+        ConfigurationSection tickRatesSection = config.getConfigurationSection("world-settings." + worldName + ".tick-rates");
+        if (tickRatesSection == null) {
+            tickRatesSection = config.getConfigurationSection("world-settings.default.tick-rates");
+        }
+        if (tickRatesSection != null) {
+            for (String key : tickRatesSection.getKeys(true)) {
+                if (tickRatesSection.isInt(key)) {
+                    int tickRate = tickRatesSection.getInt(key);
+                    tickRates.put(key.toLowerCase(Locale.ROOT), tickRate);
+                    log("  " + key + ": " + tickRate);
+                }
+            }
+        }
+        if (tickRates.isEmpty()) {
+            log("  None configured");
+        }
+    }
+    public int getTickRate(String type, String typeName, String entityType, int def) {
+        int rate = tickRates.getOrDefault(type + "." + entityType + "." + typeName, -1);
+        return rate > -1 ? rate : def;
+    }
 }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
index b1212e162ba938b3abe0df747a633ba9cbbe57c8..35036afea3713f7a1869355a0e05660069f96a8e 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
@@ -14,6 +14,11 @@ public abstract class Behavior<E extends LivingEntity> {
     private long endTimestamp;
     private final int minDuration;
     private final int maxDuration;
+    // Paper start - configurable behavior tick rate and timings
+    private static final String RATE_TYPE = "behavior";
+    private final String configKey;
+    private final co.aikar.timings.Timing timing;
+    // Paper end
 
     public Behavior(Map<MemoryModuleType<?>, MemoryStatus> requiredMemoryState) {
         this(requiredMemoryState, 60);
@@ -27,6 +32,15 @@ public abstract class Behavior<E extends LivingEntity> {
         this.minDuration = minRunTime;
         this.maxDuration = maxRunTime;
         this.entryCondition = requiredMemoryState;
+        // Paper start - configurable behavior tick rate and timings
+        String key = getClass().getName().startsWith("net.minecraft.") ? getClass().getSimpleName() : getClass().getName();
+        key = key.toLowerCase(java.util.Locale.ROOT);
+        if (key.startsWith(RATE_TYPE)) {
+            key = key.substring(RATE_TYPE.length());
+        }
+        this.configKey = key;
+        this.timing = co.aikar.timings.MinecraftTimings.getBehaviorTimings(configKey);
+        // Paper end
     }
 
     public Behavior.Status getStatus() {
@@ -34,11 +48,19 @@ public abstract class Behavior<E extends LivingEntity> {
     }
 
     public final boolean tryStart(ServerLevel world, E entity, long time) {
+        // Paper start - behavior tick rate
+        int tickRate = world.paperConfig.getTickRate(RATE_TYPE, configKey, entity.getType().id, -1);
+        if (tickRate > -1 && time < this.endTimestamp + tickRate) {
+            return false;
+        }
+        // Paper end
         if (this.hasRequiredMemories(entity) && this.checkExtraStartConditions(world, entity)) {
             this.status = Behavior.Status.RUNNING;
             int i = this.minDuration + world.getRandom().nextInt(this.maxDuration + 1 - this.minDuration);
             this.endTimestamp = time + (long)i;
+            timing.startTiming(); // Paper - behavior timings
             this.start(world, entity, time);
+            timing.stopTiming(); // Paper - behavior timings
             return true;
         } else {
             return false;
@@ -49,11 +71,13 @@ public abstract class Behavior<E extends LivingEntity> {
     }
 
     public final void tickOrStop(ServerLevel world, E entity, long time) {
+        timing.startTiming(); // Paper - behavior timings
         if (!this.timedOut(time) && this.canStillUse(world, entity, time)) {
             this.tick(world, entity, time);
         } else {
             this.doStop(world, entity, time);
         }
+        timing.stopTiming(); // Paper - behavior timings
 
     }
 
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
index 650a3f256b60998efd07b4acfd2f6168da2ff00a..85bb2305d185f0133afd5e924722456fe093ec6e 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
@@ -17,8 +17,22 @@ public abstract class Sensor<E extends LivingEntity> {
     private static final TargetingConditions ATTACK_TARGET_CONDITIONS_IGNORE_INVISIBILITY_TESTING = TargetingConditions.forCombat().range(16.0D).ignoreInvisibilityTesting();
     private final int scanRate;
     private long timeToTick;
+    // Paper start - configurable sensor tick rate and timings
+    private static final String AI_TYPE = "sensor";
+    private final String configKey;
+    private final co.aikar.timings.Timing timing;
+    // Paper end
 
     public Sensor(int senseInterval) {
+        // Paper start - configurable sensor tick rate and timings
+        String key = getClass().getName().startsWith("net.minecraft.") ? getClass().getSimpleName() : getClass().getName();
+        key = key.toLowerCase(java.util.Locale.ROOT);
+        if (key.startsWith(AI_TYPE)) {
+            key = key.substring(AI_TYPE.length());
+        }
+        this.configKey = key;
+        this.timing = co.aikar.timings.MinecraftTimings.getSensorTimings(configKey);
+        // Paper end
         this.scanRate = senseInterval;
         this.timeToTick = (long)RANDOM.nextInt(senseInterval);
     }
@@ -29,8 +43,12 @@ public abstract class Sensor<E extends LivingEntity> {
 
     public final void tick(ServerLevel world, E entity) {
         if (--this.timeToTick <= 0L) {
-            this.timeToTick = (long)this.scanRate;
+            // Paper start - configurable sensor tick rate and timings
+            this.timeToTick = (long) world.paperConfig.getTickRate(AI_TYPE, configKey, entity.getType().id, this.scanRate);
+            timing.startTiming();
+            // Paper end
             this.doTick(world, entity);
+            timing.stopTiming(); // Paper - sensor timings
         }
 
     }
